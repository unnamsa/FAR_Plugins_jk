.Language=Russian,Russian (Русский)
.PluginContents=LnkView

@Contents
$ #LnkView: работа с LNK-файлами#
Этот плагин изначально предназначен для просмотра
содержимого файлов с расширением .lnk (Windows Shortcut Files). 

Начиная с версии 2.0 плагин позволяет также
просматривать Custom Jump Lists (файлы с расширением .customDestinations-ms, обычно находящиеся в 
папке %USERPROFILE%\Recent\CustomDestinations). Также могут быть просмотрены Automatic Jump Lists 
(файлы с расширением .automaticDestinations-ms,
обычно находящиеся в папке %USERPROFILE%\Recent\AutomaticDestinations).
Для этого необходимо открыть файл .automaticDestinations-ms с помощью стандартного плагина arclite (или любого 
другого плагина, понимающего формат .msi-файлов) и далее просматривать содержимое с помощью плагина lnkview.

Начиная с версии 2.1, в плагине реализован экспорт содержимого хранящейся в системном реестре истории открывавшихся
пользователем папок (BagMRU) в LNK-файлы, которые, разумеется, в свою очередь могут быть изучены с помощью данного плагина.

Начиная с версии 3.0, в плагине реализованы базовые ~сервисные функции~@Command@ для работы с LNK-файлами, включая создание
LNK-файлов и поиск их целевых объектов.

Формат LNK-файла (или Jump List-а) распознается по внутренней сигнатуре (а не по расширению имени файла).
В случае успешного распознания формата, анализируемый файл отображается в виде виртуальной файловой системы, 
в которой сложные объекты представлены в виде папок, а конечные поля данных - в виде файлов.

Любой элемент виртуальной файловой системы может быть ~отображен в шестнадцатеричном виде~@HexView@ 
с помощью клавиши #F3#.

Шестнадцатеричные цифры, с которых начинается поле описания каждого элемента на панели, 
представляют собой смещение соответствующего объекта или поля данных внутри исходного файла.
Благодаря этому, сортировка по полю Description (задана по умолчанию) позволяет видеть объекты
в том порядке, в котором они расположены в исходном файле.

Поле длины каждого элемента на панели соответствует длине соответствующего объекта или поля данных внутри исходного файла.
Для "подпапок" FAR не показывает поле длины, однако учитывает его значение при подсчете общей длины объектов в "папке".
При экспорте в текстовый файл поля длины "папок" и "подпапок" отображаются явно.

Разбор LNK-файла производится в строгом соответствии с [MS-SHLLINK]...
но немножко глубже, чем это предусмотрено официальной документацией.

В частности, благодаря проекту WINE (из которого был позаимствован заголовочный файл pidl.h), а также собственным исследованиям
и информации, почерпнутой из статьи Joachim Metz "Windows Shell item format specification",
данный плагин разбирает внутреннюю структуру подавляющего большинства форматов ShellItemIDList'а.

Кроме того, благодаря работе Harry Parsonage "The meaning of LIFE"
стало возможным расшифровать хранящуюся в LNK-файлах информацию подсистемы File Tracker (вплоть до MAC-адреса компьютера, 
на котором располагается или ранее располагался таргет-файл).

Способы запуска плагина настраиваются через диалог конфигурации. Возможен запуск по нажатию <Enter> или <Ctrl-PgDn> на файле 
соответствующего формата, из меню плагинов (<F11>) панели FAR-а, путем набора ~команды~@Command@ с префиксом "lnk:"
в командной строке FAR'а, из ~макропрограммы~@CallFromMacro@ на языке LUA, а также из меню дисков (<ALT-F1> или <ALT-F2>).

По умолчанию панель плагина открывается в режиме "Long Descriptions". Это умолчание может быть изменено при
конфигурации плагина. Режим просмотра может быть, также, изменен в любой момент стандартными средствами FAR.

При обнаружении проблем в работе плагина, просьба слать краткое описание проблемы вместе с прикрепленным LNK-файлом 
и с сабжем "lnkviewer" на stasff@@rbcmail.ru


@Config
$ #LnkView: Конфигурация#

Выберите желаемые опции запуска и работы плагина и нажмите #Продолжить# для подтверждения или #Отменить# для отмены изменений.


@HexView
$ #LnkView: Окно шестнадцатеричного просмотра#

Формат окна шестнадцатеричного просмотра аналогичен формату окна плагина HEXITOR.

Единственным существенным дополнением является наличие панели анализа "данных под курсором".
Данная панель включается/отключается клавишей #F6# и отражает в различных форматах фрагмент содержимого файла,
начинающийся с байта, соответствующего текущему положению курсора.


Панель поддерживает отображение данных под курсором в виде:

- целочисленных знаковых и беззнаковых значений различной длины (от BYTE до QWORD),

- значений с плавающей точкой различной точности (SINGLE и DOUBLE),

- значений даты и времени в стандартах NTFS FILETIME (8 байт), DOS FILETIME (4 байта) и VARIANT TIME (8 байт).

Значения даты и времени отображаются только в том случае, когда данные под курсором могут трактоваться 
как допустимое внутреннее представление даты и времени в соответствующем стандарте.


@Command
$ #LnkView: Вызов из командной строки#

Плагин поддерживает следующие вызовы из командной строки FAR-а:
@-

#lnk:#
@+
Плагин анализирует сигнатуру и в случае успеха открывает текущий файл на активной панели FAR-а. 
@-

#lnk:ver#
@+
Плагин отображает номер своей версии в виде десятичного числа.
@-

#lnk:cat [<lnk-file>] [<text-file>]#
@+
Данная команда позволяет экспортировать данные из LNK-файла (или CustomJumpList-а) в текстовый файл (в кодировке UTF-8).
Если параметр <lnk-file> задан в виде "*", плагин экспортирует данные из всех выбранных LNK-файлов (и/или CustomJumpList-ов) 
АКТИВНОЙ панели в единый файл csv-формата.
Если на АКТИВНОЙ панели нет выбранных файлов, плагин экспортирует текущий файл АКТИВНОЙ панели, если он является LNK-файлом (или CustomJumpList-ом).
Если параметр <text-file> не задан, команда экспортирует заданный LNK-файл во временный файл и открывает его во внутреннем Viewer-е FAR'а.
Если и <lnk-file> не задан, команда  экспортирует данные из текущего элемента АКТИВНОЙ панели (если он является LNK-файлом или CustomJumpList-ом)
во временный файл и открывает его во внутреннем Viewer-е FAR'а.
@-

#lnk:follow [<lnk-file>]#
@+
Команда позволяет найти и отобразить на ПАССИВНОЙ панели целевой объект заданного LNK-файла 
(если этот целевой объект является существующим файлом или директорией).
Если ПАССИВНАЯ панель закрыта, целевой файл отображается на АКТИВНОЙ панели.
Если параметр <lnk-file> не задан, плагин анализирует текущий файл на АКТИВНОЙ панели и если этот файл оказывается LNK-файлом,
отображает его целевой объект.

С помощью диалога конфигурации плагина данная команда может быть назначена на клавиши <ENTER>, <CTRL-PGDN> или на вызов из меню плагинов (<F11>).
@-

#lnk:create [<target-file>] [<folder name>] [<target args>]#
@+
Команда позволяет создать LNK-файл, ссылающийся на заданный целевой объект, и поместить его в заданную директорию.
Если параметр <folder name> не задан, LNK-файл создается в текущей директории ПАССИВНОЙ панели, если она открыта и является обычной файловой панелью.
Если параметр <folder name> не задан, а ПАССИВНАЯ панель закрыта или не является обычной файловой панелью, плагин пытается создать LNK-файл 
в текущей директории АКТИВНОЙ панели.
Если параметр <target-file> не задан или задан в виде "*", плагин создает ссылки (LNK-файлы) на каждый из выбранных файлов АКТИВНОЙ панели.
Если на АКТИВНОЙ панели нет выбранных файлов, плагин создает ссылку на текущий файл АКТИВНОЙ панели.
Если параметры <target-file> и <folder name> заданы, остаток командной строки считается параметром <target args> и записывается
в поле \StringData\Command Args создаваемого LNK-файла.

С помощью диалога конфигурации плагина данная команда может быть назначена на вызов из меню плагинов (<F11>).

ВНИМАНИЕ:
Данная команда позволяет создавать LNK-файлы, ссылающиеся на другие LNK-файлы (что невозможно сделать обычными средствами через интерфейс MS Shell).
Когда такая цепочка косвенных ссылок обрабатывается Shell-ом, открывается целевой объект конечного LNK-файла.
Будьте осторожны - НЕ СОЗДАВАЙТЕ ЦИКЛИЧЕСКИХ ЦЕПОЧЕК LNK-ФАЙЛОВ.
@-

#lnk:addfav [<target-file>]#
@+
Данная команда эквивалентна команде "create", но создает ссылку на заданный файл в директории "Избранных ссылок",
путь к которой задается через диалог конфигурации плагина.
Созданные в директории "Избранных ссылок" LNK-файлы могут быть в дальнейшем обработаны (переименованы, перемещены) 
стандартными средствами FAR-а.

Если параметр <target-file> не задан, плагин создает ссылки (LNK-файлы) на каждый из выбранных файлов АКТИВНОЙ панели.
Если на АКТИВНОЙ панели нет выбранных файлов, плагин создает ссылку на текущий файл АКТИВНОЙ панели.

С помощью диалога конфигурации плагина данная команда может быть назначена на вызов из меню плагинов (<F11>).
@-

#lnk:fav#
@+
Переключает АКТИВНУЮ панель на директорию "Избранных ссылок", путь к которой задается через диалог конфигурации плагина.
Данная команда аналогична вызову плагина из меню дисков (<ALT-F1> или <ALT-F2>) на АКТИВНОЙ панели.
@-

#lnk:bagmru <folder name> [<hive-file>]#
@+
Данная команда позволяет экспортировать в заданную папку 
содержимое хранящейся в системном реестре или hive-файле истории открывавшихся пользователем папок (BagMRU).

Содержимое набора данных BagMRU экспортируется в набор LNK-файлов в папке, задаваемой параметром <folder name>.
В указанной папке плагин создает подпапки, соответствующие расположению ключа BagMRU в системном реестре:
@-

# Имя подпапки             Расположение в реестре#
 %SID%\Shell              HKU\%SID%\SoftWare\Microsoft\Windows\Shell
 %SID%\ShellNoRoam        HKU\%SID%\SoftWare\Microsoft\Windows\ShellNoRoam
 %SID%\Local_Shell        HKU\%SID%\SoftWare\Classes\Local Settings\SoftWare\Microsoft\Windows\Shell

@+
Где %SID% - это SID активного пользователя. Если плагин запущен с привилегиями администратора, он экспортирует
данные всех активных в данный момент пользователей.

Если плагин экспортирует данные из hive-файла, %SID%-поддиректории не создаются, а поддиректории \Shell,
\ShellNoRoam и \Local_Shell создаются только в том случае, если hive-файл содержит соответствующие ключи реестра.
Hive-файл всегда открывается в режиме read-only. Административные привилегии для экспорта данных из hive-файла
не требуются.

Каждый сгенерированный LNK-файл соответствует NodeSlot-у "базы" BagMRU. При этом время модификации файла
устанавливается равным времени модификации подключа "Shell" соответствующего NodeSlot-у ключа Bags\%NodeSlot%.
@-

#lnk:pcache <folder name> [<hive-file>]#
@+
Данная команда позволяет экспортировать в заданную папку значение хранящегося в системном реестре или hive-файле ключа
@-

HKCU\SoftWare\Microsoft\Windows\CurrentVersion\Explorer\StartPage\ProgramsCache   (для Win XP) или
HKCU\SoftWare\Microsoft\Windows\CurrentVersion\Explorer\StartPage2\ProgramsCache  (для Vista+)
@+

Если соответствующий ключ реестра существует, данные экспортируются в заданную папку в виде набора LNK-файлов.
Имя каждого LNK-файла представляет собой смещение соответствующего элемента данных внутри значения ключа реестра. 
Если плагин экспортирует данные из hive-файла, hive-файл всегда открывается в режиме read-only. 
Административные привиллегии не требуются.


@CallFromMacro
$ #LnkView: Вызов из макропрограмм#

Для вызова плагина из LUA-программы используется следующий синтаксис:
@-

#local Var1{,VarN} = Plugin.SyncCall (LnkViewGuid, "Command [Arg1[ Arg2]]"{, MCallParms})#

Где:
    LnkViewGuid - GUID плагина: "53415453-E31E-4D4C-8FE5-D6B0C6853E7C";
    Command     - любая ~команда плагина~@Command@ без префикса "lnk:",
                  либо одна из специальных команд (#ver#, #extract#, либо #parse#);
    Arg1,Arg2   - аргументы команды (как в командной строке);
    MCallParms  - ноль или более дополнительных параметров;
    Var1..VarN  - одна или более переменных макроязыка, в которые записываются 
                  возвращаемые плагином значения.
@+

Ниже приведено описание специальных команд плагина, доступных из LUA-программ. 
@-


Команда #ver#:

#local Version = Plugin.SyncCall (LnkViewGuid, "ver")#
@+

Команда позволяет LUA-программе получить версию плагина в виде числа. 

Например:
@-

#guid = "53415453-E31E-4D4C-8FE5-D6B0C6853E7C"#
#local LnkViewVer = Plugin.SyncCall (guid, "ver")  or  0#
#if  LnkViewVer < 350  then#
#    return far.Message ("LnkView plugin Version required: 3.5.0+")#
#end#
@-


Команда #extract#:

#local Flag{,Field} = Plugin.SyncCall (LnkViewGuid, "extract FileName"{, FieldName[qualifier]})#

Где:
    FileName    - абсолютный или относительный путь к LNK-файлу;
    FieldName   - ноль или более запросов на извлечение полей данных в формате виртуального пути
                  (например: "/LinkInfo/Lnk_LocalPath");
    qualifier   - ноль или один спецификатор запроса, который может принимать значения 
                  #"@@NAMES"# или #"@@VALUES"# (значение по умолчанию);
    Flag        - первое возвращаемое значение: равно #0# если #FileName# не найден 
                  или имеет неверный формат; равно #1# если #FileName# представляет собой LNK-файл;
                  равно #2# если #FileName# представляет собой CustomJumpList;
    Field       - ноль или более переменных макроязыка, в которые записываются возвращаемые плагином 
                  значения запрошенных данных из LNK-файла (или Jump List-a).
@+

Таким образом, за один вызов плагина можно получить информацию из произвольного количества полей.

В случае, когда #FieldName# задает имя конечного элемента данных, тип значения, возвращаемого в
соответствующую переменную макроязыка, соответствует типу этого элемента данных (#STRING# или #INTEGER#).

В случае, когда #FieldName# задает имя виртуальной директории, возвращается значение типа #TABLE#, которое
может индексироваться целочисленным индексом обычными средствами языка LUA и содержит #значения# (если спецификатор запроса
был не задан или был задан #"@@VALUES"#), либо #имена# (если был задан спецификатор запроса #"@@NAMES"#)
всех элементов данных, находящихся в данной виртуальной директории. При этом, имена поддиректорий всегда
заканчиваются символом "/", чтобы отличить их от имен простых элементов данных.

Например:
@-

#guid = "53415453-E31E-4D4C-8FE5-D6B0C6853E7C"#
#local Flg,names,values = Plugin.SyncCall (guid, "extract Far2.lnk", "/Header/@@names", "/Header/@@values")#

#if Flg then#
#    if type(names) == "table" then for i,v in ipairs(names) do#
#        local c = string.format("%d %s=%s", i,v,tostring(values[i]));#
#        far.Message (c);#
#        end#
#    else#
#        local c = string.format("%s=%s", names,tostring(values));#
#        far.Message (c)#
#    end#
#end#

@+

Для доступа к флагам заголовка, имени таргет-файла и его рабочей директории существуют три 
специальных запроса: #"@@Flags"#, #"@@Target"# и #"@@WorkDir"#.
Эти запросы осуществляют интеллектуальный поиск соответствующей информации в LNK-файле.

Пример:
@-

#guid = "53415453-E31E-4D4C-8FE5-D6B0C6853E7C"#
#local Flg,HeaderFlags,Target,WorkDir = Plugin.SyncCall (guid, "extract \"Far Manager 3.lnk\"", "@@flags", "@@target", "@@workdir")#

#if Flg then#
#    local c = string.format ("Flags: %08x\nTarget : %s\nWorkDir: %s",HeaderFlags,Target,WorkDir)#
#    far.Message (c)#
#end#

@+

При работе с CustomJumpList в указанных специальных запросах требуется указывать конкретный элемент Jump List'а,
к которому они относятся:
@-

#guid = "53415453-E31E-4D4C-8FE5-D6B0C6853E7C"#
#local Flg,Target = Plugin.SyncCall (guid, "extract 5afe4de1b92fc382.customDestinations-ms", "Shortcut 0/@@target")#

#if Flg then#
#    local c = string.format ("Target : %s",Target)#
#    far.Message (c)#
#end#

@-


Команда #parse#:

#local Names,Values,Descs,Offsets,Lengths,Depths = Plugin.SyncCall (LnkViewGuid, "parse <what>", xParm[, nOffset])#

Где:
    <what>      - обязательный аргумент, задающий формат разбираемого объекта. Может принимать
                  значения #Shortcut#, #JumpList#, #IDList#, #PCaсhe# или #PropStor#;
    xParm       - LUA-переменная, содержащая разбираемый объект;
    nOffset     - числовой параметр, задающий смещение (в байтах) разбираемого объекта 
                  внутри xParm (значение по умолчанию - 0);
    Names       - таблица имен элементов разбираемого объекта или nil (в случае неудачи при разборе);
    Values      - таблица значений элементов разбираемого объекта или nil (в случае неудачи при разборе);
    Descs       - таблица описаний элементов разбираемого объекта или nil (в случае неудачи при разборе);
    Offsets     - таблица смещений элементов разбираемого объекта или nil (в случае неудачи при разборе);
    Lengths     - таблица длин элементов разбираемого объекта или nil (в случае неудачи при разборе);
    Depths      - таблица глубин вложенности элементов разбираемого объекта или nil (в случае неудачи при разборе).
@+

Эта команда позволяет LUA-программе осуществить разбор данных, содержащихся в переменной xParm. Такой разбор может
быть полезен в случаях, когда значение переменной xParm было получено из внешнего источника (например, считано из
системного реестра) и включает в себя структуру (или структуры) данных, определяемую аргументом #<what>#:
@-

    #parse Shortcut# - содержимое xParm трактуется как полноценный LNK-файл (с заголовком и полями, 
                     соответствующими [MS-SHLLINK]);  
    #parse JumpList# - содержимое xParm трактуется как Custom Jump List; 
    #parse IDList#   - содержимое xParm трактуется как ShellItemIDList; 
    #parse PCache#   - содержимое xParm трактуется как последовательность ShellItemIDList,
                     характерная для значения ключа системного реестра ProgramsCache; 
    #parse PropStor# - содержимое xParm трактуется как Serialized Property Store (с заголовком и полями, 
                     соответствующими [MS-PROPSTOR]);  
@+

Параметр #xParm# должен представлять собой таблицу, содержащую РОВНО ОДИН элемент типа String. То есть,
должны выполняться условия: type(xParm)=="table", ##xParm==1 и type(xParm[1])=="string".  Это необходимо для того,
чтобы обеспечить передачу значения xParm в плагин в виде двоичного буфера (FMVT_BINARY) без промежуточных преобразований.

Параметр #nOffset# должен быть целым числом и находиться в границах от нуля до ##xParm[1]. Если значение
переменной #xParm# включает в себя несколько структур, подлежащих разбору (например, несколько ShellItemIDList-ов),
можно последовательно вызывать плагин с одним и тем же #xParm# и различными #nOffset#.

Результатом разбора являются 6 линейных таблиц, совокупность которых представляет собой линейный образ дерева разбора
заданного объекта. Последовательность элементов в указанных таблицах соответствует последовательности 
перебора узлов дерева разбора при его стандартном рекурсивном обходе. При этом, для каждого i-того узла
значение Depths[i] отражает глубину вложенности данного узла.

Такое представление позволяет LUA-программе осуществлять как тривиальный экспорт результатов разбора в плоский файл,
так и полностью восстановить древовидную структуру разобранного объекта.  


